#' Create a \pkg{gt} table object
#'
#' The `gt()` function creates a \pkg{gt} table object when provided with table
#' data. Using this function is the first step in a typical \pkg{gt} workflow.
#' Once we have the \pkg{gt} table object, we can perform styling
#' transformations before rendering to a display table of various formats (e.g.,
#' HTML, LaTeX, RTF).
#'
#' There are a few data ingest options we can consider at this stage. We can
#' choose to create a table stub with rowname captions using the `rowname_col`
#' argument. Further to this, stub row groups can be created with the
#' `groupname_col`. Both arguments take the name of a column in the input table
#' data. Typically, the data in the `groupname_col` will consist of categories
#' of data in a table and the data in the `rowname_col` are unique labels
#' (perhaps unique across the entire table or unique within groups).
#'
#' Row groups can also be created by passing a `grouped_df` to `gt()` by using
#' the [dplyr::group_by()] function on the table data. In this way, two or more
#' columns of categorical data can be used to make row groups. The
#' `stub_group.sep` argument allows for control in how the row group label will
#' appear in the display table.
#'
#' @param data A `data.frame` object or a tibble.
#' @param rowname_col The column name in the input `data` table to use as row
#'   captions to be placed in the display table stub.
#' @param groupname_col The column name in the input `data` table to use as
#'   group labels for generation of stub row groups.
#' @param rownames_to_stub An option to take rownames from the input `data`
#'   table as row captions in the display table stub.
#' @param id The table ID. By default, this will be a random ID as generated by
#'   the [random_id()] function. If set to `NULL` then no table ID will be
#'   applied.
#' @param stub_group.sep The separator to use between consecutive group names (a
#'   possibility when providing `data` as a `grouped_df` with multiple groups)
#'   in the displayed stub row group label.
#' @return An object of class `gt_tbl`.
#' @examples
#' # Create a table object using the
#' # `exibble` dataset; use the `row`
#' # and `group` columns to add a stub
#' # and row groups
#' tab_1 <-
#'   exibble %>%
#'   gt(
#'     rowname_col = "row",
#'     groupname_col = "group"
#'   )
#'
#' # The resulting object can be used
#' # in transformations (with `tab_*()`,
#' # `fmt_*()`, `cols_*()` functions)
#' tab_2 <-
#'   tab_1 %>%
#'   tab_header(
#'     title = "Table Title",
#'     subtitle = "Subtitle"
#'   ) %>%
#'   fmt_number(
#'     columns = vars(num),
#'     decimals = 2
#'   ) %>%
#'   cols_label(num = "number")
#'
#' @section Figures:
#' \if{html}{\figure{man_gt_1.svg}{options: width=100\%}}
#'
#' \if{html}{\figure{man_gt_2.svg}{options: width=100\%}}
#'
#' @family table-part creation/modification functions
#'
#' @export
gt <- function(data,
               rowname_col = "rowname",
               groupname_col = "groupname",
               rownames_to_stub = FALSE,
               auto_align = TRUE,
               id = random_id(),
               stub_group.sep = getOption("gt.stub_group.sep", " - ")) {

  # Stop if input `data` has no columns
  if (ncol(data) == 0) {
    stop("The input `data` table must have at least one column.",
         call. = FALSE)
  }

  # If the option to place rownames in the stub
  # is taken, then the `stub_df` data frame will
  # be pre-populated with rownames in the `rowname`
  # column; otherwise, this will be an empty df
  if (rownames_to_stub) {

    stub_df <-
      data.frame(
        groupname = NA_character_,
        rowname = rownames(data),
        stringsAsFactors = FALSE
      )

  } else {

    stub_df <-
      data.frame(
        groupname = rep(NA_character_, nrow(data)),
        rowname = rep(NA_character_, nrow(data)),
        stringsAsFactors = FALSE
      )
  }

  # If `rowname` is a column available in `data`,
  # place that column's data into `stub_df` and
  # remove it from `data`
  if (rowname_col %in% colnames(data)) {

    # Place the `rowname` values into `stub_df$rowname`
    stub_df[["rowname"]] <- as.character(data[[rowname_col]])

    # Remove the `rowname` column from `data`
    data[[rowname_col]] <- NULL
  }

  # If `data` is a `grouped_df` then create groups from the
  # group columns; note that this will overwrite any values
  # already in `stub_df$groupname`
  if (inherits(data, "grouped_df")) {

    group_cols <- dplyr::group_vars(data)
    group_cols <- base::intersect(group_cols, colnames(data))

    group_labels <-
      apply(data[, group_cols], 1, paste, collapse = stub_group.sep)

    # Place the `group_labels` values into `stub_df$groupname`
    stub_df[["groupname"]] <- group_labels

    # Remove all columns in `group_cols` from `data`
    data[, which(colnames(data) %in% group_cols)] <- NULL

  } else if (groupname_col %in% colnames(data)) {

    # If `groupname` is a column available in `data`,
    # place that column's data into `stub_df` and
    # remove it from `data`

    # Place the `groupname` values into `stub_df$groupname`
    stub_df[["groupname"]] <- as.character(data[[groupname_col]])

    # Remove the `groupname` column from `data`
    data[[groupname_col]] <- NULL
  }

  # Stop if input `data` has no columns (after modifying
  # `data` for groups)
  if (ncol(data) == 0) {
    stop("The `data` must have at least one column that isn't a 'group' column.",
         call. = FALSE)
  }

  # Take the input data and convert to a
  # data frame
  data_tbl <-
    data %>%
    as.data.frame(stringsAsFactors = FALSE)

  # Reset the rownames in the `data_tbl` df
  rownames(data_tbl) <- NULL

  # Create a prepopulated `rows_df` data frame
  if (nrow(data_tbl) > 0) {
    rows_df <- dplyr::tibble(rownums_start = seq(nrow(data_tbl)))
  } else {
    rows_df <- dplyr::tibble(rownums_start = NA_integer_)[-1, ]
  }

  # Add the `stub_df` object as an attribute
  attr(data_tbl, "stub_df") <- stub_df

  # Initialize the main objects
  data_tbl <-
    data_tbl %>%
    dt_data_tbl_init() %>%
    dt_heading_init() %>%
    dt_spanners_init() %>%
    dt_boxh_init() %>%
    dt_stubh_init() %>%
    dt_source_notes_init() %>%
    dt_footnotes_init() %>%
    dt_styles_init() %>%
    dt_summary_init() %>%
    dt_options_init()

  # Add the table ID to the `id` parameter
  if (!is.null(id)) {

    data_tbl <-
      data_tbl %>%
      dt_options_set_value(
        option = "table_id",
        value = id
      )
  }

  # Create an `arrange_groups` list object, which contains
  # a vector of `groupname` values in the order of first
  # appearance in `data`; if all `groupname` values are NA,
  # then use an empty character vector
  if (any(!is.na(stub_df[["groupname"]]))) {
    attr(data_tbl, "arrange_groups") <-
      list(groups = unique(stub_df[["groupname"]]))
  } else {
    attr(data_tbl, "arrange_groups") <-
      list(groups = character(0))
  }

  # Apply an empty `formats` list as an attribute
  attr(data_tbl, "formats") <- list()

  # Apply an empty `transforms` list as an attribute
  attr(data_tbl, "transforms") <- list()

  # Apply the `gt_tbl` class to the object while
  # also keeping the `data.frame` class
  class(data_tbl) <- c("gt_tbl", class(data_tbl))

  if (isTRUE(auto_align)) {
    data_tbl <-
      data_tbl %>%
      cols_align(align = "auto")
  }

  data_tbl
}
